#+OPTIONS:   H:3 num:t   toc:3 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:nil
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:   author:t creator:t timestamp:t email:t
#+TITLE: Xiaojie's Emacs init file written in org-mode
#+AUTHOR: Xiaojie Feng
#+EMAIL: fengxiaojie1997@gmail.com
#+LANGUAGE:  en
#+STARTUP: indent
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* About
** My Emacs Init File
   
This is my Emacs configuration file. Inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha]] and [[http://doc.norang.ca/org-mode.html][Bernt]], l written it
using Org-babel in literate style, to make it easy to explain.

#+BEGIN_SRC org
  Author: Xiaojie Feng
  Keywords: emacs, dotfile, config

     ___ _ __ ___   __ _  ___ ___
    / _ \ '_ ` _ \ / _` |/ __/ __|
   |  __/ | | | | | (_| | (__\__ \
  (_)___|_| |_| |_|\__,_|\___|___/
#+END_SRC
** License

#+BEGIN_EXAMPLE
  Copyright (C)  2016  Xiaojie Feng.

  Permission is granted to copy, distribute and/or modify this document under the
  terms of the GNU Free Documentation License, Version 1.3 or any later version
  published by the Free Software Foundation; with no Invariant Sections, no
  Front-Cover Texts, and no Back-Cover Texts.

  Code in this document is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by the Free
  Software Foundation, either version 3 of the License, or (at your option) any
  later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  PARTICULAR PURPOSE. See the GNU General Public License for more details.
#+END_EXAMPLE
** Commentary

#+BEGIN_EXAMPLE
  Emacs outshines all other editing software in approximately the same way that
  the noonday sun does the stars. It is not just bigger and brighter; it simply
  makes everything else vanish.
                                                               [Neal Stephenson]

  People talk about getting used to a new editor, but over time, it is precisely
  the opposite that should happen â€” the editor should get used to us.
                                                                  [Vivek Haldar]

  "Show me your ~/.emacs and I will tell you who you are."
                                                               [Bogdan Maryniuk]

  "Emacs is like a laser guided missile. It only has to be slightly
  mis-configured to ruin your whole day."
                                                                  [Sean McGrath]

  "While any text editor can save your files, only Emacs can save your
  soul."
                                                                [Per Abrahamsen]
#+END_EXAMPLE
** How to Use This Document

This document is available as an org file which you can load in Emacs and
tangle with =M-x org-babel-tangle (C-c C-v C-t)= which will create
=org-mode.el= in the same directory as the =org-mode.org= file. This will
extract all of the elisp examples in this document into a file you can include
in your =~/.emacs.d/init.el= file.

If you're new to Emacs Lisp, you probably don't want to copy and paste large
chunks of this code. Instead, copy small parts of it (always making sure to
copy a complete set of parentheses) into your =*scratch*= buffer or some other
buffer in =emacs-lisp-mode=. Use =M-x eval-buffer= to evaluate the code and see
if you like the way that Emacs behaves.

If you're viewing the Org file, you can open source code blocks (those are the
ones in begin_src) in a separate buffer by moving your point inside them and
typing C-c ' (=M-x org-edit-special=). This opens another buffer in
=emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the changes.

* Personal Information

Emacs will normally pick this up automatically, but this way I can be sure the
right information is always present.

*Note: you should modify this with your personal info.*

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Xiaojie Feng"
        user-mail-address "fengxiaojie1997@gmail.com")
#+END_SRC
* Bootstraping
** Package Management
*** =ELPA= : Packages Installer and Manager

Since Emacs 24, Emacs includes the Emacs Lisp Package Archive ([[https://www.emacswiki.org/emacs/ELPA][ELPA]]) by
default. This provides a nice way to [[http://ergoemacs.org/emacs/emacs_package_system.html][install additional packages]].

Since the default package archive doesn't include everything necessary, we need
to add more package sources.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'package)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("org" . "http://orgmode.org/elpa/")
          ("melpa" . "https://melpa.org/packages/")))

  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC

*Note:* As a Chinese user, I use the following mirrors instead. If you want to
use my emacs init file directly, you should replace the value =yes= with =no=
after variable =:tangle= in the org file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  (setq package-archives
        '(("gnu"   . "http://elpa.emacs-china.org/gnu/")
          ("melpa" . "http://elpa.emacs-china.org/melpa/")
          ("org"   . "http://elpa.emacs-china.org/org/")))

  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC
*** =Use-package= : Package Configuration Macro

This [[https://github.com/jwiegley/use-package][use-package]] macro provides more concise ways to setup package autoloads,
keybindings, and various mode configuration. The focus is on decreasing startup
time by autoloading packages instead loading them on startup.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-verbose t
        use-package-always-ensure t)

  (eval-when-compile
    (require 'use-package))

  ;; Please don't load outdated byte code
  (setq load-prefer-newer t)
#+END_SRC
** Load Multiple Emacs Files
*** My Directory Location

#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst user-emacs-savefile-dir
    (expand-file-name "savefile" user-emacs-directory)
    "This folder stores all the history and cache files")
  (defconst user-emacs-backup-dir
    (expand-file-name "backup" user-emacs-directory)
    "This folder stores all the backup files")

  (unless (file-exists-p user-emacs-savefile-dir)
    (make-directory user-emacs-savefile-dir))
  (unless (file-exists-p user-emacs-backup-dir)
    (make-directory user-emacs-backup-dir))
#+END_SRC
*** Add My Personal Elisp Files

I keep slightly more sensitive information and custom-made settings in two
different separate files so that I can easily publish my main configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst user-emacs-custom-file
    (expand-file-name "custom.el" user-emacs-directory))
  (defconst user-emacs-secret-file
    (expand-file-name "secret.el" user-emacs-directory))

  (when (file-exists-p user-emacs-custom-file)
    (load-file user-emacs-custom-file))
  (when (file-exists-p user-emacs-secret-file)
    (load-file user-emacs-secret-file))
#+END_SRC
**  =Exec-PATH= : Environment fixup

On macOS, Emacs doesn't use the shell PATH if it's not started from the shell
(started from the GUI). Let's fix that.

[[https://github.com/purcell/exec-path-from-shell][Exec-path-from-shell]] can fix this problem. It ensure environment variables
inside Emacs look the same as in the user's shell.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :defer t
    :init
    (progn
      (when (memq window-system '(mac ns))
        (exec-path-from-shell-initialize))))
#+END_SRC
** Keyboard settings for macOS users

Set keys for Apple keyboard, for Emacs in macOS.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)

    (setq mac-command-modifier 'meta)     ; make command key do Meta
    (setq mac-option-modifier 'super)     ; make option key do Super
    (setq mac-control-modifier 'control)  ; make control key do Control
    (setq ns-function-modifier 'hyper)    ; make fn key do Hyper
    )
#+END_SRC
** Library Prerequisites

Libraries provide additional Common Lisp functions and macros to make the
configuration and its dependencies work properly.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cl)                           ; provides useful things like `loop' and `setf'
  (use-package dash :ensure t)            ; a modern list library
  (use-package diminish :ensure t)        ; diminish keeps the modeline tidy
#+END_SRC
* Basic settings used everywhere
** Utilities
*** Reload emacs initialization file

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/reload-emacs-init-el-file ()
    (interactive)
    (load-file "~/.emacs.d/init.el"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/reload-emacs-init-org-file ()
    (interactive)
    (org-babel-load-file "~/.emacs.d/init.org"))
#+END_SRC
*** macOS swap Meta and Super

Swap the mapping of =Meta= and =Super= if necessary.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-swap-meta-and-super ()
    "Swap the mapping of Meta and Super.
  Very useful for people using their Mac with a
  Windows external keyboard from time to time."
    (interactive)
    (if (eq mac-command-modifier 'super)
        (progn
          (setq mac-command-modifier 'meta)
          (setq mac-option-modifier 'super)
          (message "Command is now bound to META and Option is bound to SUPER."))
      (setq mac-command-modifier 'super)
      (setq mac-option-modifier 'meta)
      (message "Command is now bound to SUPER and Option is bound to META.")))

  ;; can still use Command to expand even though Meta and Super swaped
  (global-set-key (kbd "s-/") 'hippie-expand) 
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c t k") 'prelude-swap-meta-and-super)
#+END_SRC
*** Copy filename to clipboard

Sometimes I need to copy the name of the currently visited file to the
clipboard. Emacs does not have a built-in command for that, but cooking one is
pretty straightforward:

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/
  (defun copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC
** General user interface and appearance
*** Startup screen and errors reporting

Turn off the startup messages when entering Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-startup-screen t)         ; disable startup screen
#+END_SRC

No beep when reporting errors.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function (lambda ()))   ; disable the annoying bell ring
#+END_SRC
*** Set frames title with buffer name

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq frame-title-format "%b - emacs")  ; use buffer name as frame title
#+END_SRC
*** Distinguish buffers with the same file name : =uniquify=

Make two buffers with the same file name distinguishable. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
#+END_SRC
*** Menu bar, tool bar, scroll bar. No!

Get rid of the menu bar, tool bar, and scroll bar. Useless!

#+BEGIN_SRC emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC
*** Modeline settings

Show current line and column number in modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

Indicate current file size in modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
  (size-indication-mode t)
#+END_SRC

Display time in modeline.

#+BEGIN_SRC emacs-lisp :tangle yes
  (display-time-mode 1)
#+END_SRC
*** Put empty line markers into the left hand side

Put empty line markers into the left hand side to see when a file actually
ends.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indicate-empty-lines t)
  (when (not indicate-empty-lines)
    (toggle-indicate-empty-lines))
#+END_SRC
*** Cursor and mouse

The blinking cursor is nothing, but an annoyance.

#+BEGIN_SRC emacs-lisp :tangle yes
  (blink-cursor-mode -1)                  ; No blinking cursor
#+END_SRC

Hide the mouse while typing.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq make-pointer-invisible t)         ; Hide the mouse while typing
#+END_SRC
*** Sweet hightlight

Hightlight something sweet.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-font-lock-mode 1)               ; Syntax highlight
  (global-hl-line-mode 1)                 ; Highlight cursor line
#+END_SRC

=Show-paren-mode= highlights the matching parenthesis on point.

#+BEGIN_SRC emacs-lisp :tangle yes
  (show-paren-mode 1)                      ; Highlight parenthesis pairs
  (setq show-paren-delay 0)                ; No delay
  (setq blink-matching-paren-distance nil) ; Blinking parenthesis
  (setq show-paren-style 'expression)      ; Highlight text between parenthesis
#+END_SRC

=Volatile-highlights= highlight things like undo, copy, paste, etc.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package volatile-highlights
    :init (volatile-highlights-mode)
    :diminish "")
#+END_SRC
*** Nice scrolling

Scroll the screen in a better way.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)
#+END_SRC
*** No =#autosave= and =backup~= files

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq auto-save-default nil)            ; No #autosave files
  (setq make-backup-files nil)            ; No backup~ files
#+END_SRC
*** Change "yes or no" to "y or n"

#+BEGIN_SRC emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)       ; y/n instead of yes/no
#+END_SRC
*** Confirm before quit

Confirmation is required before exiting Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC
** Navigation
*** =Winner-mode= : undo and redo window configuration

winner-mode lets you use =C-c <left>= and =C-c <right>= to switch between
window configurations. This is handy when something has popped up a buffer that
you want to look at briefly before returning to whatever you were working on.
When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (winner-mode 1)
#+END_SRC
*** =Windmove= : switching between windows

=Windmove= lets you move between windows with something more natural than
cycling through =C-x o= (=other-window=).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package windmove
    :bind
    (("s-<right>" . windmove-right)
     ("s-<left>" . windmove-left)
     ("s-<up>" . windmove-up)
     ("s-<down>" . windmove-down)))
#+END_SRC
*** =C-x o= : Moving to another window

A visual replacement for =C-x o=.

#+begin_src emacs-lisp :tangle yes
  (use-package switch-window
    :bind (("C-x o" . switch-window)))
#+end_src
*** =C-x k= : Quick kill buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun volatile-kill-buffer ()
     "Kill current buffer unconditionally."
     (interactive)
     (let ((buffer-modified-p nil))
       (kill-buffer (current-buffer))))

  ;; Unconditionally kill unmodified buffers.
  (global-set-key (kbd "C-x k") 'volatile-kill-buffer)
#+END_SRC
*** =C-a= : Smart beginning of line

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'my/smarter-move-beginning-of-line)
#+END_SRC
*** =Ace-jump= : fast cursor movement

[[https://github.com/winterTTr/ace-jump-mode][Ace-jump-mode]] is a minor mode for Emacs, enabling fast/direct cursor movement
in current view.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-jump-mode
    :defer t
    :bind (("C-c j" . ace-jump-word-mode)
           ("C-c l" . ace-jump-line-mode)
           ("C-c SPC" . ace-jump-line-mode)))
#+END_SRC
*** =Expand-region= : region selection

[[https://github.com/magnars/expand-region.el][Expand-region]] is something I have to get the hang of too. It gradually expands the
selection. Handy for Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer t
    :bind (("C-=" . er/expand-region)
           ("C--" . er/contract-region)))
#+END_SRC
** Editing
*** Coding - always UTF-8

Always, always UTF-8.

#+BEGIN_SRC emacs-lisp :tangle yes
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
#+END_SRC
*** Tabs, spaces, enters
**** Tabs vs. Space

Tabs are evil! I want spaces instead of tabs, and want exactly 2 spaces instead
of a tab. Note to self: Apparently emacs is smart enough to not do this in
Python, which is a good thing.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; make indentation commands use space only (never tab character)
  (setq-default indent-tabs-mode nil)

  ;; set current buffer's tab char's display width to 2 spaces
  (setq tab-width 2)
#+END_SRC

**** Indent or Complete - smart tab behavior

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default tab-always-indent 'complete)
#+END_SRC
**** Sentences end with one space

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)    ; Sentences end with one space
#+END_SRC
**** Bind =ENT= to =newline-and-indent=

By default, Emacs won't indent when press RET because the command bound to RET
is newline. You can enable automatic indentation by binding =RET= to
=newline-and-indent=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC
**** Always newline at end of file

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq require-final-newline t)
#+END_SRC
*** Whitespaces - show and clean

We want to show trailing whitespace. Trailing whitespace is the devil.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'whitespace)
  ;; ;; Always turn on whitespace mode
  ;; (global-whitespace-mode -1)
  ;; (diminish 'global-whitespace-mode "á—£")

  ;; Indicate trailing empty lines in the GUI
  (set-default 'indicate-empty-lines t)
  (setq show-trailing-whitespace t)

  ;; limit line length
  (setq whitespace-line-column 80)
  ;; Here are the things that whitespace-mode should highlight
  (setq whitespace-style '(face tabs empty trailing lines-tail))

  ;; Display pretty things for newlines and tabs (nothing for spaces)
  (setq whitespace-display-mappings
        ;; all numbers are Unicode codepoint in decimal. e.g. (insert-char 182 1)
        ;; 32 SPACE, 183 MIDDLE DOT
        '((space-mark nil)
          ;; 10 LINE FEED
          ;;(newline-mark 10 [172 10])
          (newline-mark nil)
          ;; 9 TAB, MIDDLE DOT
          (tab-mark 9 [183 9] [92 9])))

  ;; Disable it in certain modes where whitespace doesn't make sense.
  (setq whitespace-global-modes '(not org-mode
                                      eshell-mode
                                      shell-mode
                                      web-mode
                                      log4j-mode
                                      dired-mode
                                      emacs-lisp-mode
                                      clojure-mode
                                      lisp-mode))

  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c t w") 'whitespace-mode)
#+END_SRC

When you press =RET= to create a newline and got indented by
=eletric-indent-mode=, you have appropriate whitespace for indenting. But, if
you leave the line blank and move to the next line, the whitespace becomes
useless. =Clean-aindent-mode= helps [[https://www.emacswiki.org/emacs/CleanAutoIndent][clean up unused whitespace]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clean-aindent-mode
    :init
    (add-hook 'prog-mode-hook 'clean-aindent-mode))
#+END_SRC
*** Insert closing parens automagically

#+BEGIN_SRC emacs-lisp :tangle yes
  (electric-pair-mode 1)
#+END_SRC
*** Delete the selection with a keypress

#+BEGIN_SRC emacs-lisp :tangle yes
  (delete-selection-mode t)
#+END_SRC

*** =Undo-tree= : visualize your undos and branches

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][Undo-tree-mode]] lets you use =C-x u= (=undo-tree-visualize=) to visually walk
through the changes you've made, undo back to a certain point (or redo), and go
down different branches.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :diminish undo-tree-mode
    :init (global-undo-tree-mode)
    :config
    (progn
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+END_SRC
*** =Auto-fill= and =unfill= : Filling

Turn on [[https://www.emacswiki.org/emacs/AutoFillMode][auto-fill-mode]] to fill my paragraphs automatically, instead of =M-q=
altogether.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default fill-column 79)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)

  (global-set-key (kbd "C-c t q") 'auto-fill-mode)
#+END_SRC

Sometimes, l want to join all the lines in a paragraph into a single line,
Emacs does not have a =unfill-paragraph= command to do the inverse of fill.
Luckly, [[http://ergoemacs.org/emacs/emacs_unfill-paragraph.html][Xah Lee wrote unfill functions]] for us.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun xah-unfill-paragraph ()
    "Replace newline chars in current paragraph by single spaces.
  This command does the inverse of `fill-paragraph'.

  URL `http://ergoemacs.org/emacs/emacs_unfill-paragraph.html'
  Version 2016-07-13"
    (interactive)
    (let ((fill-column most-positive-fixnum))
      (fill-paragraph)))

  (defun xah-unfill-region (start end)
    "Replace newline chars in region by single spaces.
  This command does the inverse of `fill-region'.

  URL `http://ergoemacs.org/emacs/emacs_unfill-paragraph.html'
  Version 2016-07-13"
    (interactive "r")
    (let ((fill-column most-positive-fixnum))
      (fill-region start end)))
#+END_SRC 
*** =Hippie-expand= : Text Expansion

=Hippie-expand= looks at the word before point and tries to expand it in
various ways including expanding from a fixed list (like =`expand-abbrevâ€™=),
expanding from matching text found in a buffer (like =`dabbrev-expandâ€™=) or
expanding in ways defined by your own functions. Which of these it tries and in
what order is controlled by a configurable list of functions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq hippie-expand-try-functions-list
   '(try-expand-dabbrev
     try-expand-dabbrev-all-buffers
     try-expand-dabbrev-from-kill
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))

  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC
*** =Company= : Completion for Anything

[[http://company-mode.github.io][Company]] is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

=Completion= will start automatically after you type a few letters. Use =M-n=
and =M-p= to select, =<RET>= to complete or =<TAB>= to complete the common
part. Press =M-(digit)= to quickly complete with one of the first 10
candidates.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :diminish company-mode
    :init
    (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode 1))
#+END_SRC
*** =Yasnippet= : Code Templates

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish t
    :init
    (yas-global-mode 1))
#+END_SRC

You can view a bunch of predefined snippet [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master][here]].

*** =Anzu= : enhance isearch & query-replace

=Anzu-mode= enhances =isearch= and =query-replace= by showing total matches and
current match position.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package anzu
    :diminish anzu-mode
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp))
    :config (global-anzu-mode))
#+END_SRC
*** =Flyspell= : Spelling Checking

I like spell checking with [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] which does spell-checking on the fly as you
type using the build-in spell-check settings of ispell.

The ASpell program is better supported than ispell. It automatically configures
a personal dictionary at =~/.aspell.en.pws=, so no need to configure that.
Install ASpell with homebrew first:

#+BEGIN_SRC sh
  brew install aspell
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :defer t
    :diminish ""
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)

    (dolist (hook '(text-mode-hook org-mode-hook))
      (add-hook hook (lambda () (flyspell-mode 1))))

    (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
      (add-hook hook (lambda () (flyspell-mode -1))))

    :config
    (setq ispell-program-name "/usr/local/bin/aspell" ; use aspell instead of ispell
          ispell-dictionary "american"
          ispell-extra-args '("--sug-mode=ultra"
                              "--lang=en_US"
                              "--ignore=3")
          ispell-list-command "--list"))
#+END_SRC
** Helm - interactive completion
*** Helm core - amazing utils used everywhere

[[https://github.com/emacs-helm/helm][Helm]] makes it easy to complete various things. I find it to be easier to
configure than =ido= in order to get completion in as many places as possible,
although I prefer ido's way of switching buffers.

l learned a lot from this article: [[http://tuhdo.github.io/helm-intro.html][A Package in a league of its own: Helm]].
*Helm is Amazing!*

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :ensure t
    :diminish ""
    :init
    (require 'helm)
    (require 'helm-config)

    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    ;; rebind tab to run persistent action
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    ;; make TAB works in terminal
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    ;; list actions using C-z
    (define-key helm-map (kbd "C-z")  'helm-select-action)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-split-window-in-side-p           t
          helm-move-to-line-cycle-in-source     t
          helm-ff-search-library-in-sexp        t
          helm-scroll-amount                    8
          helm-ff-file-name-history-use-recentf t)

    (helm-mode 1)

    :config
    ;; fuzzy matching
    (setq helm-recentf-fuzzy-match t
          helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-semantic-fuzzy-match t
          helm-apropos-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-lisp-fuzzy-completion t
          helm-completion-in-region-fuzzy-match t)

    :bind (("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)

           ("C-x b" . helm-mini)
           ("C-x C-b" . helm-buffers-list)
           ("C-x C-f" . helm-find-files)
           ("C-x C-r" . helm-recentf)

           ("C-c s" . helm-swoop)
           ("C-c o" . helm-occur)

           ("C-c h a" . helm-apropos)
           ("C-c h y" . helm-yas-complete)
           ("C-c h SPC" . helm-all-mark-rings)
           ("C-c h i" . helm-semantic-or-imenu)
           ("C-c h m" . helm-man-woman)
           ))
#+END_SRC
*** Helm-swoop - searching tool

This promises to be a fast way to find things.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-swoop
    :bind (("M-i" . helm-swoop)
           ("M-I" . helm-swoop-back-to-last-point)
           ("C-c M-i" . helm-multi-swoop))
    :config
    ;; When doing isearch, hand the word over to helm-swoop
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; From helm-swoop to helm-multi-swoop-all
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    ;; Save buffer when helm-multi-swoop-edit complete
    (setq helm-multi-swoop-edit-save t
          ;; If this value is t, split window inside the current window
          helm-swoop-split-with-multiple-windows t
          ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
          helm-swoop-split-direction 'split-window-vertically
          ;; If nil, you can slightly boost invoke speed in exchange for text color
          helm-swoop-speed-or-color nil))
#+END_SRC
*** Helm-describe - keybings describe

Helm Descbinds provides an interface to emacsâ€™ describe-bindings making the
currently active key bindings interactively searchable with helm. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-descbinds
    :bind ("C-h b" . helm-descbinds)
    :init (fset 'describe-bindings 'helm-descbinds)
    :config (require 'helm-config))
#+END_SRC
*** Helm-flyspell - flyspell correct

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-flyspell
    :defer t
    :config
    (define-key flyspell-mode-map (kbd "M-S") 'helm-flyspell-correct))
#+END_SRC
** Backups

This is one of the things people usually want to change right away. By default,
Emacs saves backup files in the current directory. These are the files ending
in =~= that are cluttering up your directory lists. The following code stashes
them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= if I
really need to.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq make-backup-files t)

  (setq backup-by-copying t)
  (setq delete-old-versions t)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq kept-new-versions 6
        kept-old-versions 2)

  ;; store all backup and autosave files in the backup dir
  (setq backup-directory-alist
        `((".*" . ,user-emacs-backup-dir)))
  (setq auto-save-file-name-transforms
        `((".*" ,user-emacs-backup-dir t)))

  ;; autosave the undo-tree history
  (setq undo-tree-history-directory-alist
        `((".*" . ,user-emacs-backup-dir)))
  (setq undo-tree-auto-save-history t)
#+END_SRC
** History and temporary files
*** Recentf

=Recentf-mode= is a minor mode that builds a list of recently opened files.
Turn it on, then call =recentf-open-files= to open recently opened files fast.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'recentf)
  (recentf-mode 1) ; keep a list of recently opened files, for future sessions
  (setq recentf-save-file (expand-file-name "recentf" user-emacs-savefile-dir))

  (setq recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
#+END_SRC
*** Saveplace

When you visit a file, point goes to the last place where it was when you
previously visited the same file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'saveplace)
  (save-place-mode 1) 
  (setq save-place-file (expand-file-name "saveplace" user-emacs-savefile-dir))
#+END_SRC
*** Savehist

By default, =Savehist= mode saves only your minibuffer histories, but you can
optionally save other histories and other variables as well.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'savehist)
  (savehist-mode 1)
  (setq savehist-file (expand-file-name "savehist" user-emacs-savefile-dir))

  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC
*** Bookmarks

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'bookmark)
  (setq bookmark-default-file (expand-file-name "bookmark" user-emacs-savefile-dir))
  (setq bookmark-save-flag 1) ; everytime bookmark is changed, auto save it
#+END_SRC
*** Desktop

=Desktop-save-mode= can save and restore opened files and windows config.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;(desktop-save-mode 1)
  (setq desktop-base-file-name (expand-file-name "desktop" user-emacs-savefile-dir))
#+END_SRC
*** Eshell

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (setq eshell-directory-name (expand-file-name "eshell" user-emacs-savefile-dir))
#+END_SRC
** Dired

Tell =dired= to stop asking me whether I want to recursively delete or copy,
since I never respond to that question with =no=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
#+END_SRC

Enables "Do What I Mean" mode for dired: If I'm in a split frame with two dired
buffers, the default target to copy (and rename) will be the other window.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq dired-dwim-target t)
  (setq dired-listing-switches "-alh")
#+END_SRC

I also want dired to automatically revert, but to be quiet about it. The first
line actually enables auto-revert for any buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
#+END_SRC
** Shell

Make a shell script executable automatically on save.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; make a shell script executable automatically on save
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)

  ;; .zsh file is shell script too
  (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
#+END_SRC
** Global Key Bindings

Here are some useful global key bindings.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Align your code in a pretty way.
  (global-set-key (kbd "C-x \\") 'align-regexp)

  ;; Font size
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)

  ;; Start eshell or switch to it if it's active.
  (global-set-key (kbd "C-x m") 'eshell)

  ;; Start a new eshell even if one is active.
  (global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))

  ;; Start a regular shell if you prefer that.
  (global-set-key (kbd "C-x M-m") 'shell)

  ;; use hippie-expand instead of dabbrev
  (global-set-key (kbd "M-/") 'hippie-expand)

  ;; replace buffer-menu with ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

Bind shortcuts to some mode toggle functions.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; fullscreen frame toggle
  (global-set-key (kbd "C-c t f") 'toggle-frame-fullscreen)

  ;; flyspell-mode toggle
  (global-set-key (kbd "C-c t s") 'flyspell-mode)

  ;; whitespace-mode toggle
  (global-set-key (kbd "C-c t w") 'whitespace-mode)
#+END_SRC
** Help - =which-key=

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :config (which-key-mode))
#+END_SRC
* Aesthetics
** Color Themes

[[http://ethanschoonover.com/solarized][Solarized]] is my favourite color theme. it is available for multiple
applications, not only for Emacs. I'll set this as the default theme for
my color theme.

With the code below from [[http://stackoverflow.com/questions/23793288/cycle-custom-themes-w-emacs-24/23794179#23794179][stackoverflow]] , you can use =f12= to switch color
themes.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-solarized)

  (setq my-themes (list
                   'solarized-light
                   'solarized-dark
                   'sanityinc-solarized-light
                   'sanityinc-solarized-dark))
  (setq curr-theme my-themes)

  (defun my-theme-cycle ()
    (interactive)
    (disable-theme (car curr-theme)) ;;Nee flickeringded to stop even worse
    (setq curr-theme (cdr curr-theme))
    (if (null curr-theme) (setq curr-theme my-themes))
    (load-theme (car curr-theme) t)
    (message "%s" (car curr-theme)))

  (global-set-key [f12] 'my-theme-cycle)
  (setq curr-theme my-themes)
  (load-theme (car curr-theme) t)
#+END_SRC
** Fonts

Choosing a nice and comfortable font is quite important in your whole coding
life.

I prefer /Monaco/. And, as a Chinese, l choose /WenQuanYi/ for Chinese charset.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)

    ;; default Latin font (e.g. Consolas)
    (set-face-attribute 'default nil :family "Monaco")

    ;; default font size (point * 10)
    ;;
    ;; WARNING!  Depending on the default font,
    ;; if the size is not supported very well, the frame will be clipped
    ;; so that the beginning of the buffer may not be visible correctly.
    (set-face-attribute 'default nil :height 150)

    ;; use specific font for Chinese charset.
    ;; if you want to use different font size for specific charset,
    ;; add :size POINT-SIZE in the font-spec.
    (set-fontset-font t 'han (font-spec :name "æ–‡æ³‰é©¿ç­‰å®½å¾®ç±³é»‘"))
    )
#+END_SRC
** =Nyan-mode= : Nyan cat in modeline

Let [[https://en.wikipedia.org/wiki/Nyan_Cat][Nyan Cat]] show you your buffer position in mode line. You can scroll the
buffer by clicking on the Nyan Catâ€™s rainbow and the space in front of it.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nyan-mode
    :init (nyan-mode))
#+END_SRC
** =Rainbow-delimiters= : color delimiters for LISP

For lisp like languages, I want to witness the full power of colorful
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]! I will even set them to pastel versions of the rainbow
colors.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :init (rainbow-delimiters-mode 1))

  (set-face-attribute 'rainbow-delimiters-depth-1-face nil
                      :foreground "#78c5d6")
  (set-face-attribute 'rainbow-delimiters-depth-2-face nil
                      :foreground "#bf62a6")
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil
                      :foreground "#459ba8")
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil
                      :foreground "#e868a2")
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil
                      :foreground "#79c267")
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil
                      :foreground "#f28c33")
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil
                      :foreground "#c5d647")
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil
                      :foreground "#f5d63d")
  (set-face-attribute 'rainbow-delimiters-depth-9-face nil
                      :foreground "#78c5d6")
#+END_SRC

We also want to make unmatched parens stand out more:

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                      :foreground 'unspecified
                      :inherit 'show-paren-mismatch
                      :strike-through t)
#+END_SRC

Now we just need to adjust the hook for lisp-like languages. Possibly have to
add clojure, if I ever want to mess with that.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode)
#+END_SRC
** =Rainbow-mode= : color words for CSS

=Rainbow-mode= makes "color words" in my programs appear in the colours they
describe. Particularly good for CSS and the like.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :diminish rainbow-mode
    :config
    (add-hook 'emacs-lisp-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'html-mode-hook 'rainbow-mode)
    (add-hook 'js2-mode-hook 'rainbow-mode))
#+END_SRC
