#+TITLE: fffxj's Emacs configuration
#+AUTHOR: Xiaojie Feng
#+EMAIL: fengxiaojie1997@gmail.com

* Package Manager
** ELPA

Emacs24 之后， Emacs就像其他操作系统一样有了自己的包管理工具，如内置的 [[https://www.emacswiki.org/emacs/ELPA][ELPA(package.el)]]
，[[https://github.com/dimitri/el-get][El-Get]] ，可以使得下载插件非常方便，还能够带着一份配置文件走天下了。

ELPA 具有了自己的 repository，但是它有些保守。因此，我们还要再添加几个的软件源。
如果你没有使用过 package，现在就用它吧。你所要做的只是如下这样：

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)

  (setq package-archives
	'(("gnu" . "https://elpa.gnu.org/packages/")
	  ("org" . "http://orgmode.org/elpa/")
	  ("melpa" . "https://melpa.org/packages/")
	  ("popkit" . "http://elpa.popkit.org/packages/")))

  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC
** Use-package

[[https://github.com/jwiegley/use-package][Use-package]] 也是一个好东西，提供分离配置和提高整洁度的宏，
它还能确保软件包的安装，并提高启动速度。

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-verbose t
	use-package-always-ensure t)

  (eval-when-compile
    (require 'use-package))

  (setq load-prefer-newer t)
#+END_SRC
* Basic Settings
** Personal Information

一些关于我的个人信息。

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Xiaojie Feng"
        user-mail-address "fengxiaojie1997@gmail.com")
#+END_SRC
** Library

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash)
#+END_SRC
** Exec-path-from-shell

[[https://github.com/purcell/exec-path-from-shell][Exec-path-from-shell]] 可以使得环境变量同用户 shell 中的一致。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :defer t
    :init
    (progn
      (when (memq window-system '(mac ns))
        (exec-path-from-shell-initialize))))
#+END_SRC
** Backups

自动备份，这可能是大多数人最想首先更改的一项了吧。
Emacs 会在当前文件夹下自动备份文件，弄得混乱不堪，我选择把它关掉。

#+begin_src emacs-lisp :tangle yes
  (setq make-backup-files nil)
#+end_src   
** Auto-fill

[[https://www.emacswiki.org/emacs/AutoFillMode][Auto-fill-mode]] 是一个将过长的行截断并换行的 minor mode，当你输入 =<SPC>= 或
=<RET>= 会自动换行。

你可能疑惑为什么要保证行数小于 80。虽然在这里我不做解释，但是你可以参考
stackoverflow 上的 [[http://stackoverflow.com/questions/110928/is-there-a-valid-reason-for-enforcing-a-maximum-width-of-80-characters-in-a-code][提问]] ，来感受一下。

我尽量使得代码行宽小于 80，事实上有些项目强制如此。

我为 text-mode 和 prog-mode 和它们所有的 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Derived-Modes.html][derived modes]] 开启 auto-fill-mode。
你可以参看 [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Fill-Commands.html][Explicit Fill Commands]] 来快速截断 paragraph 和 region。
				       
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default fill-column 79)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC
** Saveplace

[[https://www.emacswiki.org/emacs/SavePlace][Saveplace]] 让光标记住在文件中的位置。

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-file (concat user-emacs-directory ".saveplace"))
#+END_SRC
** Recentf

现代编辑器或 IDE 能够打开最近文件或项目，emacs 能如此，内置包 [[https://www.emacswiki.org/emacs/RecentFiles][Recentf]]，
保存最近操作过的文件，得以快速打开。

下面的代码来自 [[https://www.masteringemacs.org/article/find-files-faster-recent-files-package][masteremacs]] ，绑定了 =ido= 和 =recentf= 。

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'recentf)

;; get rid of `find-file-read-only' and replace it with something
;; more useful.
(global-set-key (kbd "C-x C-r") 'ido-recentf-open)

;; enable recent files mode.
(recentf-mode t)

; 50 files ought to be enough.
(setq recentf-max-saved-items 50)

(defun ido-recentf-open ()
  "Use `ido-completing-read' to \\[find-file] a recent file"
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))
#+END_SRC
** Uniquify

当打开两个同名文件时，emacs 在文件名后附加"<1>"，"<2>"以示区分。
默认的这种方式并不好，因此 emacs 提供 [[https://www.emacswiki.org/emacs/uniquify][Uniquify]] ，
可以通过文件路径来区别不同的 buffers。

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC
** UTF-8

总是使用 UTF-8 编码。

#+BEGIN_SRC emacs-lisp :tangle yes
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
#+END_SRC
* Interface Enhancement
** Helm

[[https://github.com/emacs-helm/helm][Helm]] 使得许多事情易于完成，我倾向于用它来取代 ido，为了在尽可能多的地方使用它。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :ensure t
    :init
    (require 'helm-config)
    :bind (
           ("C-c h" . helm-command-prefix)
           ("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-x b" . helm-buffers-list)
           ("C-c h o" . helm-occur)
           :map helm-map
           ("<tab>" . helm-execute-persistent-action)
           ("C-i" . helm-execute-persistent-action)
           ))
#+END_SRC

进阶学习参考: [[http://tuhdo.github.io/helm-intro.html][A Package in a league of its own: Helm]]

** Undo-tree

Undo-tree 可以将所有的编辑状态用树状结构在一个 buffer 中显示出来。
然后我们轻松地可以找到我们需要的状态，甚至可以 diff 不同的状态。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure t
    :init (global-undo-tree-mode)
    :diminish undo-tree-mode)
#+END_SRC

C-x u 开启 undo-tree-visualizer-mode 后，n p 上下移动，b f 左右切换子树，t 显示时间戳，
d 显示 diff， q 退出。

** Switch-window

Switch-window 替代原有的 =C-x o= ，可以更加效率地在多个窗口中切换。

#+begin_src emacs-lisp :tangle yes
(use-package switch-window
  :bind (("C-x o" . switch-window)))
#+end_src
** Misc
*** Change "yes or no" to "y or n"

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Don't show setup message

#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-startup-message t
      initial-major-mode 'fundamental-mode)
#+END_SRC
*** Don't beep

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function (lambda ()))
#+END_SRC
*** Turn off some mode

关闭一些无用的模式，以免浪费宝贵的屏幕空间。

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (functionp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (functionp 'set-scroll-bar-mode)
    (set-scroll-bar-mode 'nil))
  (when (functionp 'mouse-wheel-mode)
    (mouse-wheel-mode -1))
  (when (functionp 'tooltip-mode)
    (tooltip-mode -1))
  (when (functionp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (functionp 'blink-cursor-mode)
    (blink-cursor-mode -1))
#+END_SRC
* Editing
** Basic settings
*** Return and newline

=RET= 之后立即缩进代码。

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Tabs vs Spaces

总是使用 =SPC= 缩进而不是 =TAB= 来执行缩紧。
并且设置缩进为 2 个字符，使代码更紧凑可读。

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
#+END_SRC
** Expand-region

[[https://github.com/magnars/expand-region.el][Expand-region]] 根据语法单元快速扩展选中的区域。[[[http://emacsrocks.com/e09.html][Video]]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer t
    :bind (("C-=" . er/expand-region)
           ("C--" . er/contract-region)))
#+END_SRC
** Multiple-cursors

[[https://github.com/magnars/multiple-cursors.el][Multiple-cursors]] 一个相当惊艳的多点编辑插件。可以看一下作者的[[http://emacsrocks.com/e13.html][视频介绍]]。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)

           ("C-c c r" . set-rectangular-region-anchor)
           ("C-c c c" . mc/edit-lines)
           ("C-c c e" . mc/edit-ends-of-lines)
           ("C-c c a" . mc/edit-beginnings-of-lines)))
#+END_SRC
** Ace-jump

[[https://github.com/winterTTr/ace-jump-mode][Ace-jump-mode]] 光标快速跳转。 =C-c <SPC>= 执行单词跳转，
=C-c M-<SPC>= 进行行跳转。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-jump-mode
    :defer t
    :bind (("C-c SPC" . ace-jump-word-mode)
           ("C-c M-SPC" . ace-jump-line-mode)))
#+END_SRC
** Flyspell

我喜欢用 [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] 进行拼写检查。并使用 ASpell 作为拼写检查工具。

#+BEGIN_SRC shell
  brew install aspell
#+END_SRC

为 text-mode 和 prog-mode 启用拼写检查，并忽略少于 3 个字符的单词。
基于 [[https://github.com/pronobis/helm-flyspell][Helm-flyspell]] 的 =M-s= 命令，列出正确的备选单词列表，然后替换错误单词，
也可以将原单词收入个人字典，之后将视为拼写正确。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :defer t
    :diminish ""
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)

    (dolist (hook '(text-mode-hook org-mode-hook))
      (add-hook hook (lambda () (flyspell-mode 1))))

    (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
      (add-hook hook (lambda () (flyspell-mode -1))))
    
    :config
    (setq ispell-program-name "/usr/local/bin/aspell"
          ispell-dictionary "american"
          ispell-extra-args '("--sug-mode=ultra"
                              "--lang=en_US"
                              "--ignore=3")
          ispell-list-command "--list")
    
    (use-package helm-flyspell
      :init
      (define-key flyspell-mode-map (kbd "M-s") 'helm-flyspell-correct)))
#+END_SRC

=~/.aspell.en.pws= 是个人字典的配置文件，Aspell 会自动生成。
* Auto Completion
** Hippie-expand

[[https://www.emacswiki.org/emacs/HippieExpand][Hippie-expand]] 是一个小而强大的内置补全功能，它根据一个优先列表来进行补全，
这是说，首先使用当前的 buffer 补全，如果找不到，就到别的可见的窗口里寻找， 
如果还找不到，再到所有打开的 buffer ，kill-ring，文件名，简称列表 ...
中寻找。

特别有意思的是 try-expand-line，可以补全整整一行文字。
有时两行文字大致相同，只有几个字不一样，如果懒得去拷贝粘贴，
那么就可以输入这行文字的前面几个字，然后按两下 =M-/= 就能得到那一行。

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-/") 'hippie-expand)

  (setq hippie-expand-try-functions-list
   '(try-expand-dabbrev
     try-expand-dabbrev-all-buffers
     try-expand-dabbrev-from-kill
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))
#+END_SRC
** Yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] 是一个非常强大的模板补全扩展，键入几个字母就能完成补全，
还能轻松定制自己的模板。

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
      :init
      (yas-global-mode 1)
      :diminish t)
#+END_SRC

使用 <TAB> 完成补全。
** Company

[[https://company-mode.github.io][Company]] 意为 "company anything"，它能满足我绝大部分的补全需要，

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :ensure t
      :init
      (add-hook 'after-init-hook 'global-company-mode)
      :diminish company-mode)
#+END_SRC

利用 [[https://github.com/expez/company-quickhelp][company-quickhelp]] ，可以增加适当的延迟。它依赖 [[https://github.com/pitkali/pos-tip/blob/master/pos-tip.el][top-tip]] 。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode 1))
#+END_SRC

在键入几个字母后会开启 Company，M-n 和 M-p 选择，<RET> 或 <TAB> 完成补全。
* Programming
** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] 非常重要的插件，支持大多数动态语言的语法检查。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :defer t
    :bind (("C-c n" . flycheck-next-error)
           ("C-c p" . flycheck-previous-error)
           ("C-c =" . flycheck-list-errors))
    :init (global-flycheck-mode)
    :diminish ""
    :config
    (progn
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (use-package flycheck-tip
        :config (flycheck-tip-use-timer 'verbose))
      (use-package helm-flycheck
        :init (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
      (use-package flycheck-haskell
        :init (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))))
#+END_SRC
** Gdb

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gdb-many-windows t        ; use gdb-many-windows by default
        gdb-show-main t)          ; Non-nil means display source file containing the main routine at startup
#+END_SRC
** Magit

[[https://github.com/magit/magit][Magit]] 是版本控制系统 [[https://git-scm.com][Git]] 常用命令的接口封装，好用，美观，sweet。
如果你没听说过 Git，那我推荐你阅读 [[http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000][Git 教程]]，
来学习一下这个优秀的版本控制系统。当然别忘记安装 Git：

#+BEGIN_SRC shell
  brew install git
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands magit-status magit-blame
    :init
    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    
    :config
    (setq magit-branch-arguments nil
          ;; use ido to look for branches
          magit-completing-read-function 'magit-ido-completing-read
          ;; don't put "origin-" in front of new branch names by default
          magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
          magit-push-always-verify nil
          ;; Get rid of the previous advice to go into fullscreen
          magit-restore-window-configuration t)

    :bind ("C-x g" . magit-status))
#+END_SRC

我将最重要的命令 =magit-status= 绑定至 =C-x g= 。

[[https://www.youtube.com/watch?v%3Dzobx3T7hGNA][Magit Basics]] 将带你初识 Magit，这个视频也很甜。

* Programming language
** SML

因华盛顿大学的 Programming Language 使用SML语言教学，而配置。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sml-mode)
  (setenv "PATH" (concat "/usr/local/smlnj/bin:" (getenv "PATH")))
  (setq exec-path (cons "/usr/local/smlnj/bin" exec-path))
#+END_SRC
* Appearance
** Color Theme

From: [[http://stackoverflow.com/questions/23793288/cycle-custom-themes-w-emacs-24/23794179#23794179][stackoverflow]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package color-theme)
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-solarized)

  (setq my-themes (list
                   'solarized-light
                   'solarized-dark
                   'sanityinc-solarized-light
                   'sanityinc-solarized-dark))
                   
  (setq curr-theme my-themes)

  (defun my-theme-cycle ()
    (interactive)
    (disable-theme (car curr-theme)) ;;Nee flickeringded to stop even worse
    (setq curr-theme (cdr curr-theme))
    (if (null curr-theme) (setq curr-theme my-themes))
    (load-theme (car curr-theme) t)
    (message "%s" (car curr-theme)))

  (global-set-key [f12] 'my-theme-cycle)
  (setq curr-theme my-themes)
  (load-theme (car curr-theme) t)
#+END_SRC

F12 在 my-themes 列表中快速切换主题。

** Windows

内置的 Winner-mode 通过 =C-c <left>= 和 =C-c <right>= 对 windows
执行 undo 和 redo。

#+BEGIN_SRC emacs-lisp :tangle yes
  (winner-mode 1)
#+END_SRC
** Modeline

[[https://github.com/TeMPOraL/nyan-mode/][Nyan-mode]] 开启后，会有一只拖有彩虹的 Nyan Cat 出现在 mode line 上，
它会随着光标移动而左右移动，以指示光标在 buffer 中的位置。

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package nyan-mode
      :init
      (nyan-mode))
#+END_SRC

为什么显示行号和列号呢？

#+BEGIN_SRC emacs-lisp :tangle yes
  (column-number-mode 1)
#+END_SRC
** Fonts

选择一个舒适的字体对于编程着实重要。如果有兴趣的话，你可以参看一下：
[[http://hivelogic.com/articles/top-10-programming-fonts/][Top 10 Programming Fonts]] 或 [[https://www.sitepoint.com/top-10-programming-fonts/][10 of the Best Programming Fonts]]
以感受一下不同的字体。

我比较钟爱 Monaco ，Mac 自带的字体之一。
中文字体选用文泉驿等宽微米黑，Google 安装之即可。

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)

    ;; default Latin font (e.g. Consolas)
    (set-face-attribute 'default nil :family "Monaco")

    ;; default font size (point * 10)
    (set-face-attribute 'default nil :height 150)

    ;; use specific font for Chinese charset.
    ;; if you want to use different font size for specific charset,
    ;; add :size POINT-SIZE in the font-spec.
    (set-fontset-font t 'han (font-spec :name "文泉驿等宽微米黑"))
    )
#+END_SRC
** Symbols

美化符号显示。

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (boundp 'global-prettify-symbols-mode)
    (add-hook 'emacs-lisp-mode-hook
              (lambda ()
                (push '("lambda" . ?λ) prettify-symbols-alist)))
    (add-hook 'clojure-mode-hook
              (lambda ()
                (push '("fn" . ?ƒ) prettify-symbols-alist)))
    (global-prettify-symbols-mode +1))
#+END_SRC

