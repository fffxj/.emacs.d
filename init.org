#+TITLE: fffxj's Emacs configuration
#+AUTHOR: Xiaojie Feng
#+EMAIL: fengxiaojie1997@gmail.com

* About
** My Emacs Init File

This is my emacs init file. I’ve written it in a literate style, to make it
easy to explain. The notes also include hyperlinks to where I stole it. ;-)

This document is available as an org file which you can load in Emacs and
tangle with =C-c C-v C-t= which will create org-mode.el in the same directory as
the org-mode.org file. This will extract all of the elisp examples in this
document into a file you can include in your emacs config file. 

#+BEGIN_SRC org
Author: Xiaojie Feng
Keywords: emacs, dotfile, config

   ___ _ __ ___   __ _  ___ ___
  / _ \ '_ ` _ \ / _` |/ __/ __|
 |  __/ | | | | | (_| | (__\__ \
(_)___|_| |_| |_|\__,_|\___|___/
#+END_SRC
** License

#+BEGIN_EXAMPLE
Copyright (C)  2016  Xiaojie Feng.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.

Code in this document is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation, either
version 3 of the License, or (at your option) any later version.

This code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#+END_EXAMPLE
** Commentary

#+BEGIN_EXAMPLE
"Show me your ~/.emacs and I will tell you who you are."
                                                         [Bogdan Maryniuk]

"Emacs is like a laser guided missile. It only has to be slightly 
mis-configured to ruin your whole day."
                                                            [Sean McGrath]

"While any text editor can save your files, only Emacs can save your
soul."
                                                          [Per Abrahamsen]
#+END_EXAMPLE
** How to use

If you're new to Emacs Lisp, you probably don't want to copy and paste large
chunks of this code. Instead, copy small parts of it (always making sure to
copy a complete set of parentheses) into your =*scratch*= buffer or some other
buffer in =emacs-lisp-mode=. Use =M-x eval-buffer= to evaluate the code and see
if you like the way that Emacs behaves. See [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in
Emacs Lisp]] for more details on Emacs Lisp. You can also find the manual by
using =C-h i= (info) and choosing "Emacs Lisp Intro". 

This document is available as an org file which you can load in Emacs and
tangle with =C-c C-v C-t= which will create org-mode.el in the same directory as
the org-mode.org file. This will extract all of the elisp examples in this
document into a file you can include in your .emacs file. 

* Package Initialization
** ELPA

Starting with emacs 24, it comes with a package system called [[https://www.emacswiki.org/emacs/ELPA][ELPA]] (Emacs Lisp
Package Archive). It make the task of installing, update and removing easier,
as well as inform users new packages created by the community.  

Emacs gets a list of packages from sources, called package archive. Package
archive is the same as repository in Linux. =package.el= supports multiple ELPA
repositories. we need to add more repositories to get all the sweet goodness.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)

  (setq package-archives
	'(("gnu" . "https://elpa.gnu.org/packages/")
	  ("org" . "http://orgmode.org/elpa/")
	  ("melpa" . "https://melpa.org/packages/")))

  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC
** Use-package

This [[https://github.com/jwiegley/use-package][use-package]] macro provides more concise ways to setup package autoloads,
keybindings, and various mode configuration. The focus is on decreasing startup
time by autoloading packages instead loading them on startup. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-verbose t
	use-package-always-ensure t)

  (eval-when-compile
    (require 'use-package))

  (setq load-prefer-newer t)
#+END_SRC
* General settings
** Personal Information

Some personal information about me.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Xiaojie Feng"
        user-mail-address "fengxiaojie1997@gmail.com")
#+END_SRC
** My Directory Location

#+BEGIN_SRC emacs-lisp :tangle yes
  (defconst xj-cache-dir (expand-file-name "~/.emacs.d/cache/")
    "dir with volatile data")
  (defconst xj-data-dir  (expand-file-name "~/.emacs.d/data/")
    "dir for user data")

  (unless (file-exists-p xj-cache-dir)
    (make-directory xj-cache-dir))
#+END_SRC
** Library

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash)
#+END_SRC
* Basics settings
** General user interface and appearance

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Messages
  (setq inhibit-startup-message t)        ; No message at startup
  (setq ring-bell-function (lambda ()))   ; No beep when reporting errors

  ;; Frames
  (setq frame-title-format "%b - emacs")  ; Use buffer name as frame title

  ;; Bars
  (tool-bar-mode -1)                      ; No toolbar
  (menu-bar-mode -1)                      ; No menubar
  (scroll-bar-mode -1)                    ; No scrollbar

  ;; Modeline
  (line-number-mode 1)                    ; Display the current line number
  (column-number-mode 1)                  ; Display the current column number

  ;; Highlight
  (global-font-lock-mode 1)               ; Syntax highlight
  (global-hl-line-mode 1)                 ; Highlight cursor line

  ;; Scrolling
  (setq scroll-margin 0                   ; Nice scrolling
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)
#+END_SRC
** Files and sessions

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Files
  (setq auto-save-timeout 60)             ; Autosave every minute
  (setq make-backup-files nil)            ; No backup files ~

  ;; Sessions
  (setq confirm-kill-emacs 'yes-or-no-p)  ; Confirm quit
#+END_SRC
** Cursor and mouse

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Cursor
  (blink-cursor-mode -1)                  ; No blinking cursor

  ;; Mouse
  (setq make-pointer-invisible t)         ; Hide the mouse while typing
#+END_SRC
** Buffers and windows

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Windows
  (windmove-default-keybindings)          ; Shift arrows switch windows
#+END_SRC
** Tabs, spaces, lines and parenthesis

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Tabs
  (setq-default indent-tabs-mode nil)     ; Use spaces instead of tabs
  (setq tab-width 2)                      ; Length of tab is 2 SPC

  ;; Spaces
  (setq sentence-end-double-space nil)    ; Sentences end with one space

  ;; Lines
  (setq require-final-newline 't)                  ; Always newline at end of file
  (global-set-key (kbd "RET") 'newline-and-indent) ; New lines are always indented

  ;; Parenthesis
  (show-paren-mode 1)                      ; Highlight parenthesis pairs
  (setq blink-matching-paren-distance nil) ; Blinking parenthesis
  (setq show-paren-style 'expression)      ; Highlight text between parenthesis
#+END_SRC
** Global key bindings

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Align your code in a pretty way.
  (global-set-key (kbd "C-x \\") 'align-regexp)

  ;; Font size
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)

  ;; Start eshell or switch to it if it's active.
  (global-set-key (kbd "C-x m") 'eshell)

  ;; Start a new eshell even if one is active.
  (global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))

  ;; Start a regular shell if you prefer that.
  (global-set-key (kbd "C-x M-m") 'shell)

  ;; use hippie-expand instead of dabbrev
  (global-set-key (kbd "M-/") 'hippie-expand)

  ;; replace buffer-menu with ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
** Miscellaneous

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Alias
  (defalias 'yes-or-no-p 'y-or-n-p)       ; y/n instead of yes/no
#+END_SRC
* OS special setting
** Paths

Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI
inherits a default set of environment variables. 

[[https://github.com/purcell/exec-path-from-shell][Exec-path-from-shell]] is a GNU Emacs library to ensure environment variables
inside Emacs look the same as in the user's shell. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :defer t
    :init
    (progn
      (when (memq window-system '(mac ns))
        (exec-path-from-shell-initialize))))
#+END_SRC
* Useful settings
** Uniquify

With [[https://www.emacswiki.org/emacs/uniquify][uniquify]], buffers visiting "/u/mernst/tmp/Makefile" and
"/usr/projects/zaphod/Makefile" would be named "Makefile|tmp" and
"Makefile|zaphod" or other style, respectively (instead of “Makefile” and
“Makefile<2>”). 

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
#+END_SRC
* Persistence
** Bookmarks

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; `C-x r m' – set a bookmark at the current location (e.g. in a file)
  ;; ‘C-x r b' – jump to a bookmark
  ;; `C-x r l' – list your bookmarks
  ;; `M-x bookmark-delete' – delete a bookmark by name

  (require 'bookmark)
  (setq bookmark-default-file "~/.emacs.d/bookmarks")
  (setq bookmark-save-flag 1)             ; autosave each change
#+END_SRC
** Recentf

=Recentf= is a minor mode that builds a list of recently opened files. This
list is automatically saved across sessions on exiting Emacs - you can then
access this list through a command or the menu.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'recentf)
  (setq recentf-max-saved-items 200
        recentf-max-menu-items 15)
  (recentf-mode)
#+END_SRC
** Saveplace

When you visit a file, point goes to the last place where it was when you
previously visited the same file.  

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-file (concat user-emacs-directory ".saveplace"))
#+END_SRC
** Savehist

By default, =Savehist= mode saves only your minibuffer histories, but you can
optionally save other histories and other variables as well.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC
* Helm
** Helm core
[[https://github.com/emacs-helm/helm][Helm]] makes it easy to complete various things. I find it to be easier to
configure than ido in order to get completion in as many places as possible,
although I prefer ido's way of switching buffers.

l learned a lot from this article: [[http://tuhdo.github.io/helm-intro.html][A Package in a league of its own: Helm]] 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :ensure t
    :diminish ""
    :init
    (require 'helm)
    (require 'helm-config)

    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    ;; rebind tab to run persistent action
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    ;; make TAB works in terminal
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    ;; list actions using C-z
    (define-key helm-map (kbd "C-z")  'helm-select-action)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-split-window-in-side-p           t
          helm-move-to-line-cycle-in-source     t
          helm-ff-search-library-in-sexp        t
          helm-scroll-amount                    8
          helm-ff-file-name-history-use-recentf t)

    (helm-mode 1)

    :config
    ;; fuzzy matching
    (setq helm-recentf-fuzzy-match t
          helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-semantic-fuzzy-match t
          helm-apropos-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-lisp-fuzzy-completion t
          helm-completion-in-region-fuzzy-match t)

    :bind (("C-c h" . helm-command-prefix)
           ("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)

           ("C-x b" . helm-mini)
           ("C-x C-b" . helm-buffers-list)
           ("C-x C-f" . helm-find-files)
           ("C-x C-r" . helm-recentf)

           ("C-c s" . helm-swoop)
           ("C-c o" . helm-occur)
           
           ("C-h a" . helm-apropos)
           ("C-h y" . helm-yas-complete)
           ("C-h SPC" . helm-all-mark-rings)
           ("C-h i" . helm-semantic-or-imenu)
           ("C-h m" . helm-man-woman)
           ))
#+END_SRC
** Helm-swoop

This promises to be a fast way to find things.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-swoop
    :bind (("M-i" . helm-swoop)
           ("M-I" . helm-swoop-back-to-last-point)
           ("C-c M-i" . helm-multi-swoop))
    :config
    ;; When doing isearch, hand the word over to helm-swoop
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    ;; From helm-swoop to helm-multi-swoop-all
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
    ;; Save buffer when helm-multi-swoop-edit complete
    (setq helm-multi-swoop-edit-save t
          ;; If this value is t, split window inside the current window
          helm-swoop-split-with-multiple-windows t
          ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
          helm-swoop-split-direction 'split-window-vertically
          ;; If nil, you can slightly boost invoke speed in exchange for text color
          helm-swoop-speed-or-color nil))
#+END_SRC

** Helm-describe

Helm Descbinds provides an interface to emacs’ describe-bindings making the
currently active key bindings interactively searchable with helm. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-descbinds
    :bind ("C-h b" . helm-descbinds)
    :init (fset 'describe-bindings 'helm-descbinds)
    :config (require 'helm-config))
#+END_SRC
* Navigation
** Switch-window

A visual replacement for =C-x o=.

#+begin_src emacs-lisp :tangle yes
(use-package switch-window
  :bind (("C-x o" . switch-window)))
#+end_src
** Ace-jump

[[https://github.com/winterTTr/ace-jump-mode][Ace-jump-mode]] is a minor mode for Emacs, enabling fast/direct cursor movement
in current view. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-jump-mode
    :defer t
    :bind (("C-c SPC" . ace-jump-word-mode)
           ("C-c M-SPC" . ace-jump-line-mode)))
#+END_SRC
* File manager
** Dired

Dired is sweet, I require =dired-x= also so I can hit =C-x C-j= and go directly
to a dired buffer. 

Setting =ls-lisp-dirs-first= means directories are always at the top. Always
copy and delete recursively. Also enable hl-line-mode in dired, since it's
easier to see the cursor then. 

To start, a helper to use "open" to open files in dired-mode with =M-o=
(similar to Finder in OSX). 

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/dired-open ()
  "Use the OSX `open' command to open a file with the correct editor"
  (interactive)
  (save-window-excursion
    (dired-do-async-shell-command
     "~/bin/open" current-prefix-arg
     (dired-get-marked-files t current-prefix-arg))))
#+END_SRC

And then some other things to setup when dired runs. =C-x C-q= to edit
writable-dired mode is aawwweeeesssoooommee, it makes renames super easy.

#+BEGIN_SRC emacs-lisp :tangle no
(defun my/dired-mode-hook ()
  (my/turn-on-hl-line-mode)
  (toggle-truncate-lines 1))

(use-package dired
  :bind ("C-x C-j" . dired-jump)
  :config
  (progn
    (use-package dired-x
      :init (setq-default dired-omit-files-p t)
      :config
      (add-to-list 'dired-omit-extensions ".DS_Store"))
    (customize-set-variable 'diredp-hide-details-initially-flag nil)
    (use-package dired+)
    (use-package dired-aux
      :init (use-package dired-async))
    (put 'dired-find-alternate-file 'disabled nil)
    (setq ls-lisp-dirs-first t
          dired-recursive-copies 'always
          dired-recursive-deletes 'always
          dired-dwim-target t
          ;; -F marks links with @
          dired-ls-F-marks-symlinks t
          delete-by-moving-to-trash t
          ;; Auto refresh dired
          global-auto-revert-non-file-buffers t
          wdired-allow-to-change-permissions t)
    (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
    (define-key dired-mode-map (kbd "C-M-u") 'dired-up-directory)
    (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
    (define-key dired-mode-map (kbd "C-x C-q") 'wdired-change-to-wdired-mode)
    (add-hook 'dired-mode-hook #'my/dired-mode-hook)))
#+END_SRC
* Project manager
** Projectile

Projectile guide: [[http://tuhdo.github.io/helm-projectile.html][Exploring large projects with Projectile and Helm Projectile]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :defer t
    :init (projectile-global-mode 1)
    :config
    (setq projectile-completion-system 'helm)
    (helm-projectile-on)

    ;; Helm-projectile-switch-project settings
    (setq projectile-switch-project-action 'helm-projectile)
    )
#+END_SRC
* Editing
** Unicode
*** UTF-8

Always, always UTF-8.

#+BEGIN_SRC emacs-lisp :tangle yes
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
#+END_SRC
** Alignment
** Indentation
** Whitespace

#+BEGIN_SRC emacs-lisp :tagnle yes
  (require 'whitespace)
  ;; Always turn on whitespace mode
  ;; (global-whitespace-mode 1)
  ;; (diminish 'global-whitespace-mode "")

  ;; Indicate trailing empty lines in the GUI
  (set-default 'indicate-empty-lines t)
  (setq show-trailing-whitespace t)

  ;; limit line length
  (setq whitespace-line-column 80) 
  ;; Here are the things that whitespace-mode should highlight
  (setq whitespace-style '(face tabs empty trailing lines-tail))

  ;; Display pretty things for newlines and tabs (nothing for spaces)
  (setq whitespace-display-mappings
        ;; all numbers are Unicode codepoint in decimal. e.g. (insert-char 182 1)
        ;; 32 SPACE, 183 MIDDLE DOT
        '((space-mark nil)
          ;; 10 LINE FEED
          ;;(newline-mark 10 [172 10])
          (newline-mark nil)
          ;; 9 TAB, MIDDLE DOT
          (tab-mark 9 [183 9] [92 9])))

  ;; Disable it in certain modes where whitespace doesn't make sense.
  (setq whitespace-global-modes '(not org-mode
                                      eshell-mode
                                      shell-mode
                                      web-mode
                                      log4j-mode
                                      dired-mode
                                      emacs-lisp-mode
                                      clojure-mode
                                      lisp-mode))
#+END_SRC
** Comments
** Filling
*** Auto-fill

[[https://www.emacswiki.org/emacs/AutoFillMode][Auto-fill-mode]] 是一个将过长的行截断并换行的 minor mode，当你输入 =<SPC>= 或
=<RET>= 会自动换行。

你可能疑惑为什么要保证行数小于 80。虽然在这里我不做解释，但是你可以参考
stackoverflow 上的 [[http://stackoverflow.com/questions/110928/is-there-a-valid-reason-for-enforcing-a-maximum-width-of-80-characters-in-a-code][提问]] ，来感受一下。

我尽量使得代码行宽小于 80，事实上有些项目强制如此。

我为 text-mode 和 prog-mode 和它们所有的 [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Derived-Modes.html][derived modes]] 开启 auto-fill-mode。
你可以参看 [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Fill-Commands.html][Explicit Fill Commands]] 来快速截断 paragraph 和 region。
				       
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default fill-column 79)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)

  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC
*** Unfilling Paragraph

Unfilling a paragraph joins all the lines in a paragraph into a single line. 
Taken from [[https://www.emacswiki.org/emacs/UnfillParagraph][here]].

It works where a line ends with a newline character (”\n”) and paragraphs are
separated by blank lines. To make a paragraph end in a single newline then use
the function below:

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  (define-key global-map "\M-Q" 'unfill-paragraph)
#+END_SRC
** Cursors
*** Multiple-cursors

[[https://github.com/magnars/multiple-cursors.el][Multiple-cursors]] 一个相当惊艳的多点编辑插件。可以看一下作者的[[http://emacsrocks.com/e13.html][视频介绍]]。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)

           ("C-c c r" . set-rectangular-region-anchor)
           ("C-c c c" . mc/edit-lines)
           ("C-c c e" . mc/edit-ends-of-lines)
           ("C-c c a" . mc/edit-beginnings-of-lines)))
#+END_SRC
** Parentheses
*** Rainbow-delimiters

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :init (rainbow-delimiters-mode 1))
#+END_SRC
** Region
*** Expand-region

[[https://github.com/magnars/expand-region.el][Expand-region]] is something I have to get the hang of too. It gradually expands the
selection. Handy for Emacs Lisp. [[[http://emacsrocks.com/e09.html][Video]]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer t
    :bind (("C-=" . er/expand-region)
           ("C--" . er/contract-region)))
#+END_SRC
** Spelling
*** Flyspell

I like spell checking with [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]], which uses the built-in spell-check
settings of ispell. 

The ASpell project is better supported than ispell.

#+BEGIN_SRC shell
  brew install aspell
#+END_SRC

ASpell automatically configures a personal dictionary at =~/.aspell.en.pws=, so
no need to configure that. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :defer t
    :diminish ""
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)

    (dolist (hook '(text-mode-hook org-mode-hook))
      (add-hook hook (lambda () (flyspell-mode 1))))

    (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
      (add-hook hook (lambda () (flyspell-mode -1))))
    
    :config
    (setq ispell-program-name "/usr/local/bin/aspell"
          ispell-dictionary "american"
          ispell-extra-args '("--sug-mode=ultra"
                              "--lang=en_US"
                              "--ignore=3")
          ispell-list-command "--list")
    
    (use-package helm-flyspell
      :init
      (define-key flyspell-mode-map (kbd "M-S") 'helm-flyspell-correct)))
#+END_SRC
** Templates
*** Abbrev

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; sample use of emacs abbreviation feature

  (define-abbrev-table 'global-abbrev-table '(

      ;; math/unicode symbols
      ("8in" "∈")
      ("8nin" "∉")
      ("8inf" "∞")
      ("8luv" "♥")
      ("8smly" "☺")

      ;; email
      ("8me" "fengxiaojie1997@gmail.com")

      ;; computing tech
      ("8wp" "Wikipedia")
      ("8ms" "Microsoft")
      ("8g" "Google")
      ("8win" "Windows")

      ;; normal english words
      ("8alt" "alternative")
      ("8char" "character")
      ("8def" "definition")
      ("8bg" "background")
      ("8kb" "keyboard")
      ("8ex" "example")
      ("8kbd" "keybinding")
      ("8env" "environment")
      ("8var" "variable")
      ("8ev" "environment variable")
      ("8cp" "computer")

      ;; signature
      ("8xj" "Xiaojie Feng")

      ;; url

      ;; emacs regex
      ("8d" "\\([0-9]+?\\)")
      ("8str" "\\([^\"]+?\\)\"")

      ;; shell commands
      ("8ditto" "ditto -ck --sequesterRsrc --keepParent src dest")
      ("8im" "convert -quality 85% ")

      ("8f0" "find . -type f -size 0 -exec rm {} ';'")
      ("8rsync" "rsync -z -r -v -t --exclude=\"*~\" --exclude=\".DS_Store\" --exclude=\".bash_history\" --exclude=\"**/xx_xahlee_info/*\"  --exclude=\"*/_curves_robert_yates/*.png\" --exclude=\"logs/*\"  --exclude=\"xlogs/*\" --delete --rsh=\"ssh -l xah\" ~/web/ xah@example.com:~/")
      ))

  ;; stop asking whether to save newly added abbrev when quitting emacs
  (setq save-abbrevs nil)

  ;; turn on abbrev mode globally
  (setq-default abbrev-mode t)
#+END_SRC
** Undo
*** Undo-tree

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]] treats undo history as a branching tree of changes, similar to
the way Vim handles it. This makes it substantially easier to undo and redo any
change, while preserving the entire history of past states.

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package undo-tree
      :diminish undo-tree-mode
      :init (global-undo-tree-mode)
      :config
      (progn
        (setq undo-tree-visualizer-timestamps t)
        (setq undo-tree-visualizer-diff t)))
#+END_SRC
** Search and replace

Anzu-mode enhances isearch & query-replace by showing total matches and current match position

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package anzu
    :diminish anzu-mode
    :init (global-anzu-mode 1))

  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)
#+END_SRC
** Highlight

Highlights things like undo, copy, paste, etc.

#+BEGIN_SRC emacs-lisp :tangle yes
   (defun my/turn-on-volatile-highlights ()
       (interactive)
       (volatile-highlights-mode t)
       (diminish 'volatile-highlights-mode))

     (use-package volatile-highlights
       :defer t
       :init
       (progn
         (require 'volatile-highlights) ;; vh has a problem with autoloads
         (add-hook 'org-mode-hook #'my/turn-on-volatile-highlights)
         (add-hook 'prog-mode-hook #'my/turn-on-volatile-highlights)))
#+END_SRC
* Completion
** Hippie-expand

=Hippie-expand= looks at the word before point and tries to expand it in
various ways including expanding from a fixed list (like =`expand-abbrev’=),
expanding from matching text found in a buffer (like =`dabbrev-expand’=) or
expanding in ways defined by your own functions. Which of these it tries and in
what order is controlled by a configurable list of functions.  

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-/") 'hippie-expand)

  (setq hippie-expand-try-functions-list
   '(try-expand-dabbrev
     try-expand-dabbrev-all-buffers
     try-expand-dabbrev-from-kill
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))
#+END_SRC
** Company

[[http://company-mode.github.io][Company]] is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates. 

It comes with several back-ends such as Elisp, Clang, Semantic, Eclim,
Ropemacs, Ispell, CMake, BBDB, Yasnippet, dabbrev, etags, gtags, files, 
keywords and a few others. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :diminish company-mode
    :init
    (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode 1))
#+END_SRC
* Development environment

Reference: [[http://tuhdo.github.io/c-ide.html][C/C++ Development Environment for Emacs]] 

** Sources code navigation
*** Ggtags

[[https://github.com/leoliu/ggtags][Ggtags]] is emacs frontend to GNU Global source code tagging system.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ggtags)
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                (ggtags-mode 1))))

  (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
  (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
  (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
  (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
  (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
  (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)

  (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq helm-gtags-prefix-key "\C-cg")
  (setq helm-gtags-ignore-case t
        helm-gtags-auto-update t
        helm-gtags-use-input-at-cursor t
        helm-gtags-pulse-at-cursor t
        helm-gtags-suggested-key-mapping t)

  (use-package helm-gtags
    :diminish ""
    :init (helm-gtags-mode t))

  (add-hook 'dired-mode-hook 'helm-gtags-mode)
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
  (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
#+END_SRC
*** Basic movement

#+BEGIN_SRC org
  | Key binding     | Command            | Descriptioin                                                           |
  |-----------------+--------------------+------------------------------------------------------------------------|
  | C-M-f           | forward-sexp       | move forward over a balanced expression that can be a pair or a symbol |
  | C-M-b           | backward-sexp      | ..                                                                     |
  | C-M-k           | kill-sexp          | kill balanced expression forward that can be a pair or a symbol        |
  | C-M-<SPC>/C-M-@ | mark-sexp          | put mark after following expression that can be a pair or a symbol     |
  | C-M-a           | beginning-of-defun | moves point to beginning of a function                                 |
  |                 |                    |                                                                        |
#+END_SRC
** CEDET
*** What is GEDET?

CEDET is a (C)ollection of (E)macs (D)evelopment (E)nvironment (T)ools written
with the end goal of creating an advanced development environment in Emacs.
CEDET includes common features such as intelligent completion, source code
navigation, project management, code generation with templates . CEDET also
provides a framework for working with programming languages; support for new
programming languages can be added and use CEDET to provide IDE-like features. 

CEDET can give you code completion, but this process takes time and can block
your Emacs while it is doing so. If you have large project, you may not want to
use CEDET for code completion. But, you can use CEDET perfectly for utilities
that work at file scope i.e. refactoring local variables in a function in a
file. 

*** Semantic minor modes

To enable code completion using Semantic, add the following code: 

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'cc-mode)
  (require 'semantic)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)

  (semantic-mode 1)
#+END_SRC

** Sources code editing
*** Space and Tabs

To convert between TAB and space, you also have two commands: =tabify= to turn an
active region to use TAB for indentation, and =untabify= to turn an active region
to use space for indentation. 

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use space to indent by default
  (setq-default indent-tabs-mode nil)

  ;; set appearance of a tab that is represented by 2 spaces
  (setq-default tab-width 2)
#+END_SRC
*** Folding

Emacs has a minor mode called =hs-minor-mode= that allows users to fold and
hide blocks of text. Blocks are defined by regular expressions which match the
start and end of a text region. For example, anything in between ={= and =}= is
a block. The regular expressions are defined in =hs-special-modes-alist=.

Setup for C/C++:

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook   'hs-minor-mode)
#+END_SRC

Default Keybinding:

| Keybinding  | Command          | Description                                                     |
|-------------+------------------+-----------------------------------------------------------------|
| C-c @ C-c   | hs-toggle-hiding | Toggle hiding/showing of a block                                |
| C-c @ C-h   | hs-hide-block    | Select current block at point and hide it                       |
| C-c @ C-l   | hs-hide-level    | Hide all block with indentation levels below this block         |
| C-c @ C-s   | hs-show-block    | Select current block at point and show it                       |
| C-c @ C-M-h | hs-hide-all      | Hide all top level blocks, displaying only first and last lines |
| C-c @ C-M-s | hs-show-all      | Show everything                                                 |
*** Narrowing

Narrowing means making only a text portion in current buffer visible. Narrowing
is useful when you want to perform text editing on a small part of the buffer
without affecting the others. For example, you want to delete all =printf=
statements in current functions, using =flush-lines= command. But if you do so,
you will also delete =printf= outside the current function, which is undesirable.
By narrowing, you can safely remove all those printf and be certain that
nothing else is changed accidentally. 

Default Keybinding:

| Keybinding | Command          | Description                                |
|------------+------------------+--------------------------------------------|
| C-x n n    | narrow-to-region | Narrow buffer to active region             |
| C-x n d    | narrow-to-defun  | Narrow buffer to current function at point |
| C-x n w    | widen            | Widen buffer                               |
*** Whitespace

When working with source code, we must pay attention to trailng whitespace. It
is always useful to view whitespace in current buffer before committing your
code.  

To clean up trailing whitespace, you can also run =whitespace-cleanup= command. 

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c w") 'whitespace-mode)

  ;; show unncessary whitespace that can mess up your diff
  (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))
#+END_SRC
*** Identation
**** Code style
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Available C style:
  ;; “gnu”: The default style for GNU projects
  ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
  ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
  ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
  ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
  ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
  ;; “linux”: What the Linux developers use for kernel development
  ;; “python”: What Python developers use for extension modules
  ;; “java”: The default style for java-mode (see below)
  ;; “user”: When you want to define your own style
  (setq
   c-default-style "linux" ;; set style to "linux"
   )
#+END_SRC
**** Setup identation

By default, Emacs won't indent when press RET because the command bound to RET 
is newline. You can enable automatic indentation by binding =RET= to
=newline-and-indent=. 

#+BEGIN_SRC emacs-lisp :tangle yes
  ; automatically indent when press RET
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC
**** Package: =clean-aindent-mode=

When you press RET to create a newline and got indented by eletric-indent-mode,
you have appropriate whitespace for indenting. But, if you leave the line blank
and move to the next line, the whitespace becomes useless. This package helps
clean up unused whitespace. 

More Detail: [[https://www.emacswiki.org/emacs/CleanAutoIndent][Emacswiki: Clean Auto Indent]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clean-aindent-mode
    :init
    (add-hook 'prog-mode-hook 'clean-aindent-mode))
#+END_SRC
*** =Smartparens= for manipulating pairs

=smartparens= is a minor mode that provides many features for manipulating
pairs. Pair can be simple as parentheses or brackets, or can be programming
tokens such as =if= … =fi= or =if= … end in many languages. The most basic and
essential feature is automatic closing of a pair when user inserts an opening
one. 

#+BEGIN_SRC emacs-lisp :tangle yes
    ;;(require 'smartparens-config)
    ;;(show-smartparens-global-mode +1)
    ;;(smartparens-global-mode 1)
    (use-package smartparens
      :defer t
      :diminish ""
      :init
      (show-smartparens-global-mode +1)
      (smartparens-global-mode 1)
      :config
      (progn
        ;; when you press RET, the curly braces automatically
        ;; add another newline
        (sp-with-modes '(c-mode c++-mode)
                       (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
                       (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                                                 ("* ||\n[i]" "RET"))))
        ))
#+END_SRC

For complete documentation, please refer to [[https://github.com/Fuco1/smartparens/wiki#information-for-new-users][Smartparens manual]].

*** Code template using =yasnippet=

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates. 

Bundled language templates include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX,
HTML, CSS and more. The snippet syntax is inspired from TextMate's syntax, you
can even import most TextMate templates to YASnippet. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish t
    :init
    (yas-global-mode 1))
#+END_SRC

Basic Usage:

In major modes where yasnippet has snippets available, typing a certain keyword
and /TAB/ insert a predefined snippet. For example, in a C buffer, if you type
=for= and *TAB* , it expands to: 

#+BEGIN_SRC c
  for (i = 0; i < N; i++) {
      ...point will be here....
  }
#+END_SRC

You can view a bunch of predefined snippet [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master][here]].

* Programming Tools
** Utilities

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; make a shell script executable automatically on save
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)

  ;; .zsh file is shell script too
  (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
#+END_SRC
** Shell

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (setq eshell-directory-name (expand-file-name "eshell" user-emacs-directory))
#+END_SRC
** Projectile

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package projectile
    :init
    (setq projectile-cache-file (expand-file-name  "projectile.cache" user-emacs-directory))
    (projectile-global-mode t))
#+END_SRC
** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] 非常重要的插件，支持大多数动态语言的语法检查。

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :defer t
    :bind (;;("C-c n" . flycheck-next-error)
           ;;("C-c p" . flycheck-previous-error)
           ("C-c =" . flycheck-list-errors))
    :init (global-flycheck-mode)
    :diminish ""
    :config
    (progn
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (use-package flycheck-tip
        :config (flycheck-tip-use-timer 'verbose))
      (use-package helm-flycheck
        :init (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
      (use-package flycheck-haskell
        :init (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))))
#+END_SRC
** Compilation

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq  compilation-scroll-output 'first-error  ; scroll until first error
         compilation-read-command nil            ; don't need enter
         compilation-window-height 12            ; keep it readable
         compilation-auto-jump-to-first-error t  ; jump to first error auto
         compilation-auto-jump-to-next-error t)  ; jump to next error
#+END_SRC
** Gdb

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gdb-many-windows t        ; use gdb-many-windows by default
        gdb-show-main t)          ; Non-nil means display source file containing the main routine at startup
#+END_SRC
** Version control
*** Ediff

#+BEGIN_SRC emacs-lisp :tangle yes
;; ediff - don't start another frame
(require 'ediff)
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
*** Magit

[[https://github.com/magit/magit][Magit]] 是版本控制系统 [[https://git-scm.com][Git]] 常用命令的接口封装，好用，美观，sweet。
如果你没听说过 Git，那我推荐你阅读 [[http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000][Git 教程]]，
来学习一下这个优秀的版本控制系统。当然别忘记安装 Git：

#+BEGIN_SRC shell
  brew install git
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands magit-status magit-blame
    :init
    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    
    :config
    (setq magit-branch-arguments nil
          ;; use ido to look for branches
          magit-completing-read-function 'magit-ido-completing-read
          ;; don't put "origin-" in front of new branch names by default
          magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
          magit-push-always-verify nil
          ;; Get rid of the previous advice to go into fullscreen
          magit-restore-window-configuration t)

    :bind ("C-x g" . magit-status))
#+END_SRC

我将最重要的命令 =magit-status= 绑定至 =C-x g= 。

[[https://www.youtube.com/watch?v%3Dzobx3T7hGNA][Magit Basics]] 将带你初识 Magit，这个视频也很甜。

*** Git-messenger

#+begin_src emacs-lisp :tangle no
(use-package git-messenger
  :bind (("C-x v m" . git-messenger:popup-message)))
#+end_src
* Programming language
** SML

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sml-mode)
  (setenv "PATH" (concat "/usr/local/smlnj/bin:" (getenv "PATH")))
  (setq exec-path (cons "/usr/local/smlnj/bin" exec-path))
#+END_SRC
* Display
** Full Screen

#+BEGIN_SRC emacs-lisp :tangle yes
;;  (global-set-key (kbd "C-M-f") 'toggle-frame-fullscreen)
#+END_SRC
** Color Theme

[[http://ethanschoonover.com/solarized][Solarized]] is my favourite color theme. it is available for multiple
applications, not only for emacs. I'll set this as the default theme for
my color theme.

From: [[http://stackoverflow.com/questions/23793288/cycle-custom-themes-w-emacs-24/23794179#23794179][stackoverflow]]

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package color-theme)
  (use-package solarized-theme)
  (use-package color-theme-sanityinc-solarized)

  (setq my-themes (list
                   'solarized-light
                   'solarized-dark
                   'sanityinc-solarized-light
                   'sanityinc-solarized-dark))
                   
  (setq curr-theme my-themes)

  (defun my-theme-cycle ()
    (interactive)
    (disable-theme (car curr-theme)) ;;Nee flickeringded to stop even worse
    (setq curr-theme (cdr curr-theme))
    (if (null curr-theme) (setq curr-theme my-themes))
    (load-theme (car curr-theme) t)
    (message "%s" (car curr-theme)))

  (global-set-key [f12] 'my-theme-cycle)
  (setq curr-theme my-themes)
  (load-theme (car curr-theme) t)
#+END_SRC
** Modeline
*** Nyan-mode

Let [[https://en.wikipedia.org/wiki/Nyan_Cat][Nyan Cat]] show you your buffer position in mode line.

Now with the ability to scroll the buffer by clicking on the Nyan Cat’s rainbow
and the space in front of it. 

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package nyan-mode
      :init
      (nyan-mode))
#+END_SRC
** Fonts

Choosing a good and comfortable font is quite important in your whole coding
life.

I prefer Monaco. And, as a Chinese, l choose WenQuanYi for Chinese charset.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)

    ;; default Latin font (e.g. Consolas)
    (set-face-attribute 'default nil :family "Monaco")

    ;; default font size (point * 10)
    (set-face-attribute 'default nil :height 150)

    ;; use specific font for Chinese charset.
    ;; if you want to use different font size for specific charset,
    ;; add :size POINT-SIZE in the font-spec.
    (set-fontset-font t 'han (font-spec :name "文泉驿等宽微米黑"))
    )
#+END_SRC
** Symbols

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp :tangle no
  (when (boundp 'global-prettify-symbols-mode)
    (add-hook 'emacs-lisp-mode-hook
              (lambda ()
                (push '("lambda" . ?λ) prettify-symbols-alist)))
    (add-hook 'clojure-mode-hook
              (lambda ()
                (push '("fn" . ?ƒ) prettify-symbols-alist)))
    (global-prettify-symbols-mode +1))
#+END_SRC
* Org
** Introduction

[[http://orgmode.org][Org-mode]] is for keeping notes, maintaining ToDo lists, doing project planning,
and authoring with a fast and effective plain-text system. 

Org Mode can be used as a very simple folding outliner or as a complex GTD
system or tool for reproducible research and literate programming. 

If you are a org-mode newbie, please take a look at [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][David O'Toole Org tutorial]]
first, then try to learn more about org-mode.

[[http://orgmode.org/guide/][The compact guide]] and [[http://orgmode.org/manual/index.html][the complete manual]] is the best manual. [[http://orgmode.org/worg/][Org Worg]], the
most large org-mode wiki is really helpful. 

*** Activation

The minimal customization needed to use Org-mode is – Nothing at all! \par
Org-mode works out of the box, and besides the steps described in the manual to
[[http://orgmode.org/manual/Activation.html#Activation][activate]] it, nothing is needed at all. Just open a .org file, press =C-c [= to
tell org that this is a file you want to use in your agenda, and start putting
your life into plain text. 

OK, for completeness, let's just repeat what is needed to activate Org-mode in
files with =.org= extension, and a few important key assignments. 

The last four lines define global keys for some most important commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Standard key bindings
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-directory "~/org")
#+END_SRC
** Todo items
*** Todo keywords

The parentheses indicate keyboard shortcuts that I can use to set the task
state. =@= and =!= toggle logging. =@= prompts you for a note, and =!=
automatically logs the timestamp of the state change. 

#+BEGIN_SRC emacs-lisp :tangle yes
    (setq org-todo-keywords
          '((sequence
             "TODO(t)"  ; next action
             "TOBLOG(b)"  ; next action
             "STARTED(s)"
             "WAITING(w@/!)"
             "SOMEDAY(.)"
             "|" "DONE(x!)" "CANCELLED(c@)")
            (sequence "LEARN" "TRY" "TEACH" "|" "COMPLETE(x)")
            (sequence "TOSKETCH" "SKETCHED" "|" "POSTED")
            (sequence "TOBUY" "TOSHRINK" "TOCUT"  "TOSEW" "|" "DONE(x)")
            (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foreground "gray" :weight bold))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-log-done 'time)
  (setq org-use-fast-todo-selection t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-enforce-todo-dependencies t)
#+END_SRC
** Capture-Refile-Archive

An important part of any organization system is the ability to quickly capture
new ideas and tasks, and to associate reference material with them. Org does
this using a process called [[http://orgmode.org/manual/Capture-_002d-Refile-_002d-Archive.html#Capture-_002d-Refile-_002d-Archive][capture]]. It also can store files related to a task
(attachments) in a special directory. Once in the system, tasks and projects
need to be moved around. Moving completed project trees to an archive file
keeps the system compact and fast. 

*** Capture

Capture lets you quickly store notes with little interruption of your work
flow. Org's method for capturing new items is heavily inspired by John Wiegley
excellent remember.el package. Up to version 6.36, Org used a special setup for
remember.el, then replaced it with org-remember.el. As of version 8.0,
org-remember.el has been completely replaced by org-capture.el. 

[[http://members.optusnet.com.au/~charles57/GTD/datetree.html][Capture mode and Date Trees in org-mode]] 

**** Setup capture

The following customization sets a default target file for notes, and defines a
global key for capturing new material. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC
**** Using capture

[[http://orgmode.org/manual/Using-capture.html#Using-capture][More details]]

**** Capture templates

You can use [[http://orgmode.org/manual/Capture-templates.html#Capture-templates][templates]] for different types of capture items, and for different
target locations.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (setq org-capture-templates
  ;;      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
  ;;             "* TODO %?\n  %i\n  %a")
  ;;        ("j" "Journal" entry (file+datetree "~/org/journal.org")
  ;;         "* %?\nEntered on %U\n  %i\n  %a")))

  (setq org-capture-templates
        '(("n" "iNterruption" entry (file+datetree "~/org/orgfile.org")
           "* %?\n  %a\n  %K" ;; :clock-in t :clock-resume t
           )
          ("k" "breaK" entry (file+datetree "~/org/orgfile.org")
           "* %?\n  %a\n  %K" ;; :clock-in t :clock-resume t
           )
          ("t" "Todo" entry (file "~/org/orgfile.org")
           "* TODO %? \n  %a\n  %K" ;; :clock-in t :clock-resume t
           )
          ("1" "Todo by tomorrow" entry (file "~/org/orgfile.org")
           "* TODO %? \n  :PROPERTIES:\n  :EXPIRY:   [%(gds/tomorrow)]\n  :END:\n  %a\n  %K"
           )
          ("2" "Todo within a week" entry (file "~/org/orgfile.org")
           "* TODO %? \n  :PROPERTIES:\n  :EXPIRY:   [%(gds/next-week)]\n  :END:\n  %a\n  %K"
           )
          ("3" "Todo within a fortnight" entry (file "~/org/orgfile.org")
           "* TODO %? \n  :PROPERTIES:\n  :EXPIRY:   [%(gds/in-a-fortnight)]\n  :END:\n  %a\n  %K"
           )
          ("4" "Todo within a month" entry (file "~/org/orgfile.org")
           "* TODO %? \n  :PROPERTIES:\n  :EXPIRY:   [%(gds/next-month)]\n  :END:\n  %a\n  %K"
           )
          ("5" "Todo within two months" entry (file "~/org/orgfile.org")
           "* TODO %? \n  :PROPERTIES:\n  :EXPIRY:   [%(gds/in-two-months)]\n  :END:\n  %a\n  %K"
           )
          ("i" "IT" entry (file+olp "~/org/orgfile.org" "HomeIT")
           "* TODO %? \n  %a\n  %K" ;; :clock-in t :clock-resume t
           )
          ("s" "Spam" item (file+olp "~/org/orgfile.org" "HomeIT" "Spam")
           "%a\n  %K" :immediate-finish t)
          ("l" "Link" entry (file+olp "~/org/orgfile.org" "Random" "Links")
           "* %a %? %K\n  :PROPERTIES:\n  :CREATED:   %U\n  :END:" :unnarrowed t ;; :clock-in t :clock-resume t
           )
          ("m" "Music" entry (file+olp "~/org/orgfile.org" "Random" "Music")
           "* %? %a %K\n  :PROPERTIES:\n  :CREATED:   %U\n  :END:" :unnarrowed t ;; :clock-in t :clock-resume t
           )
          ("b" "Blog" entry (file+olp "~/org/website.org" "Blog ideas")
           "* TODO %? \n  %a\n  %K" ;; :clock-in t :clock-resume t
           )
          ("c" "Current" entry (clock)
           "* %?\n  %a\n  %K" ;; :clock-in t :clock-resume t
           )))
#+END_SRC
*** Refile and copy

[[http://orgmode.org/manual/Refile-and-copy.html#Refile-and-copy][More details]]

*** Archiving

When a project represented by a (sub)tree is finished, you may want to move the
tree out of the way and to stop it from contributing to the agenda. Archiving
is important to keep your working files compact and global searches like the
construction of agenda views fast.

| Keybinding  | Command                       | Description                                                                                        |   |   |
|-------------+-------------------------------+----------------------------------------------------------------------------------------------------+---+---|
| C-c C-x C-a | (org-archive-subtree-default) | Archive the current entry using the command specified in the variable org-archive-default-command. |   |   |
  
** Agenda views

Due to the way Org works, TODO items, time-stamped items, and tagged headlines
can be scattered throughout a file or even a number of files. To get an
overview of open action items, or of events that are important for a particular
date, this information must be collected, sorted and displayed in an organized
way. 

The extracted information is displayed in a special agenda buffer. This buffer
is read-only, but provides commands to visit the corresponding locations in the
original Org files, and even to edit these files remotely. 

*** Agenda files

The information to be shown is normally collected from all [[http://orgmode.org/manual/Agenda-files.html#Agenda-files][agenda files]], the
files listed in the variable =org-agenda-files=. If a directory is part of this
list, all files with the extension .org in this directory will be part of the
list. 

| Keybinding | Command                    | Description                                                                                                                                                                                                |
|------------+----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| C-c [      | (org-agenda-file-to-front) | Add current file to the list of agenda files. The file is added to the front of the list. If it was already in the list, it is moved to the front. With a prefix argument, file is added/moved to the end. |
| C-c ]      | (org-remove-file)          | Remove current file from the list of agenda files.                                                                                                                                                         |
| C-'        | (org-cycle-agenda-files)   |                                                                                                                                                                                                            |

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files (list "~/org/work.org"
                               "~/org/school.org" 
                               "~/org/home.org"
                               "~/org/projects.org"))
#+END_SRC
*** Proper syntax highlighting

To make org mode syntax color embeded source code:

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
#+END_SRC

The following displays the contents of code blocks in Org-mode files using the
major-mode of the code. It also changes the behavior of TAB to as if it were
used in the appropriate major mode. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+END_SRC
** Babel

[[http://orgmode.org/manual/Working-With-Source-Code.html#Working-With-Source-Code][Babel]] makes it possible to embed source code of any language into your
org-files. You can then pretty-print that code, or run it as you wish. This
makes org a great platform for [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] as championed by [[https://en.wikipedia.org/wiki/Donald_Knuth][Don Knuth]].
These config files are written this way, and these web pages are generated
automatically by org. 

*** What languages?

By default, only emacs lisp code is allowed to eval. If you need other
languages, you need to add this to your emacs init:

#+BEGIN_SRC emacs-lisp :tangle yes
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (haskell . t)
     (clojure . t)
     (ruby . t)
     (dot . t)
     (sh . t)
     (latex . t)))
#+END_SRC

*** Proper syntax highlighting

To make org mode syntax color embeded source code:

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
#+END_SRC

The following displays the contents of code blocks in Org-mode files using the
major-mode of the code. It also changes the behavior of TAB to as if it were
used in the appropriate major mode. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+END_SRC

It is possible to inhibit the evaluation of code blocks during export. Setting
the =org-export-babel-evaluate= variable to nil will ensure that no code blocks
are evaluated as part of the export process. 

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-export-babel-evaluate nil)
#+END_SRC  

